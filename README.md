# Java의 정석 정리

# Chapter 02 | 변수(variable)

## 1.1 변수(variable)란?

> “변수란, 단 하나의 값을 저장할 수 있는 메모리 공간.”
> 

## 1.3 변수의 명명규칙

1. 식별자를 만들 때는 다음과 같은 규칙을 지킬 것

> 1. 대소문자가 구분되며 길이에 제한이 없다.
 - True와 true는 서로 다른 것으로 간주한다.
2. 예약어를 사용해서는 안 된다.
 - true는 예약어라서 사용할 수 없지만. True는 가능하다.
3. 숫자로 시작해서는 안 된다.
 - top10은 허용하지만, 7up은 허용되지 않는다.
4. 특수문자는 ‘_’와 ‘$’만을 허용한다.
 - $harp은 허용되지만, S#arp은 허용되지 않는다.
> 
1. 그 외에 필수적인 것은 아니지만 자바 프로그래머들에게 권장하는 규칙들

> 1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
 - 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
 - lastIndexOf, StringBuffer
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 ‘_’로 구분한다.
 - PI, MAX_NUMBER
> 

## 2.2 상수와 리터럴(constant & literal)

‘상수(constant)’는 변수와 마찬가지로 ‘값을 저장할 수 있는 공간’이지만, 변수와 달리 한번 값을 저장하면 다른 값으로 변경할 수 없다. 상수를 선언하는 방법은 변수와 동일하며, 단지 변수의 타입 앞에 키워드 ‘final’을 붙여주기만 하면 된다.

```java
final int MAX_SPEED = 10; // 상수 MAX_SPEED를 선언 & 초기화
```

그리고 상수는 반드시 선언과 동시에 초기화해야 하며, 그 후 부터는 상수의 값을 변경하는 것이 허용되지 않는다.

```java
final int MAX_SPEED;       // 에러. 상수는 선언과 동시에 초기화해야함
final int MAX_VALUE = 100; // OK. 선언과 동시에 초기화 했음
MAX_VALUE = 200;           // 에러. 상수의 값은 변경할 수 없음
```

상수의 이름은 모두 대문자로 하는 것이 암묵적인 관례이며, 여러 단어로 이루어져있는 경우 ‘_’로 구분한다.

### 리터널(literal)

리터널은 단지 우리가 기존에 알고 있던 ‘상수’의 다른 이름일 뿐이다.

> 변수(variable) 하나의 값을 저장하기 위한 공간
상수(constant) 값을 한번에 저장할 수 있는 공간
리터널(literal) 그 자체로 값을 의미하는 것
> 

### 리터럴의 타입과 접미사

변수에 타입이 있는 것처럼 리터럴에도 타입이 있다.

| 종류 | 리터럴 | 접미사 |
| --- | --- | --- |
| 논리형 | false, true | 없음 |
| 정수형 | 123, 0b0101, 077, 0xFF, 100L | L |
| 실수형 | 3.14, 3.0e8, 1.4f, 0x1.0p-1 | f, d |
| 문자형 | ‘A’, ‘1’, ‘\n’ | 없음 |
| 문자열 | “ABC”, “123”, “A”, “true” | 없음 |

10진수 외에도 2, 8, 16진수로 표현된 리터럴을 변수에 저장할 수 있다.

```java
int octNum = 010;  //  8진수 10, 10진수로 8
int hexNum = 0x10; // 16진수 10, 10진수로 16
int binNum = 0b10; //  2진수 10, 10진수로 2
```

정수형 리터럴의 중간에 구분자’_’를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있다.

```java
long big = 100_000_000_000L;      // long big = 1000000000000L;
long hex = 0xFFFF_FFFF_FFFF_FFFF; // long hex = 0xFFFFFFFFFFFFFFFFL;
```

실수형에서는 float타입의 리터럴에 접미사 ‘f’ 또는 ‘F’를 붙인다.

```java
float pi = 3.14f;     // 접미사 f 대신 F를 사용해도 된다.
double rate = 1.618d; // 접미사 d 대신 D를 사용해도 된다. (double은 생략 가능)
```

리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e, 그리고 접미사 f, F, d, D를 포함하고 있으면 실수형 리터럴로 간주된다.

| 자료형 | 실수형 리터럴 | 다른 형태의 동등한 표현 |
| --- | --- | --- |
| double | 10. | 10.0 |
| double | .10 | 0.10 |
| float | 10f | 10.0f |
| float | 3.14e3f | 3140.0f |
| double | 1e1 | 10.0 |
| double | 1e-3 | 0.001 |

### 문자 리터럴과 문자열 리터럴

덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합한다.

> 문자열 + **any type** —> 문자열 + **문자열** —> 문자열
**any type** + 문자열 —> **문자열** + 문자열 —> 문자열
> 

## 2.3 형식화된 출력 - printf()

printf()의 지시자

| 지시자 | 설명 |
| --- | --- |
| %b | 불리안(boolean) 형식으로 출력 |
| %d | 10진(decimal) 정수의 형식으로 출력 |
| %o | 8진(octal) 정수의 형식으로 출력 |
| %x, %X | 16진(hexa-decimal) 정수의 형식으로 출력 |
| %f | 부동 소수점(floating-point) 표현식의 형식으로 출력 |
| %e, %E | 지수(exponent) 표현식의 형식으로 출력 |
| %c | 문자(character)로 출력 |
| %s | 문자열(string)로 출력 |

10진수를 2진수로 출력해주는 지시자는 없기 때문에, 정수를 2진 문자열로 변환해주는 `Integer.toBinaryString(int i)`를 사용해야 한다. 이 메서드는 정수를 2진수로 변환해서 문자열로 반환하므로 지시자 ‘%s’를 사용했다.

```java
System.out.printf("binNum=%s%n", Integer.toBinaryString(binNum);
```

그리고 C언어에서는 char타입의 값을 지시자 ‘%d’로 출력할 수 있지만, 자바에서는 허용되지 않는다. 아래와 같이 int타입으로 형변환해야만 ‘%d’로 출력할 수 있다.

```java
System.out.printf("c = %c, %d %n", c, (int)c); // 형변환이 꼭 필요하다.
```

## 2.4 화면에서 입력받기 - Scanner

Scanner클래스를 사용하려면, 아래의 한 문장을 추가해줘야 한다.

```java
import java.util.Scanner; // Scanner클래스를 사용하기 위해 추가
```

그 다음엔 Scanner클래스의 객체를 생성한다.

```java
Scanner scanner = new Scanner(System.in); // Scanner클래스의 객체를 생성
```

그리고 nextLine()이라는 메서드를 호출하면, 입력대기 상태에 있다가 입력을 마치고 ‘엔터키’를 누르면 입력한 내용이 문자열로 반환된다.

```java
String input = scanner.nextLine(); // 입력받은 내용을 input에 저장
int num = Integer.parseInt(input); // 입력받은 내용을 int타입의 값으로 변환
```

Scanner클래스에는 nextInt()나 nextFloat()와 같이 변환없이 숫자로 바로 입력받을 수 있는 메서드들이 있고, 이 메서드들을 사용하면 문자열을 숫자로 변환하는 수고는 하지 않아도 된다.

```java
int num = scanner.nexInt(); // 정수를 입력받아서 변수 num에 저장
```

### next()와 nextLine()의 차이

- next()
    - 공백을 기준으로 한 단어 또는 한 문자씩 입력받는다.
    - 버퍼에 입력된 문자나 문자열에서 `공백 전까지의 단어`를 읽는다.
    - `개행 문자를 가져오지 않는다.`
- nextLine()
    - 문자또는 `엔터를 치기 전까지의 문장 전체`를 입력받는다.
    - `버퍼에 입력된 문자열을 개행 문자까지 다 가져온다.`

## 5.1 형변환(캐스팅, casting)이란?

프로그램을 작성하다 보면 같은 타입뿐만 아니라 서로 다른 타입간의 연산을 수행해야하는 경우도 있다. 이럴 때는 연산을 수행하기 전에 타입을 일치 시켜야 하는데, 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 ‘형변환(casting)’이라고 한다.

> 형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
> 

## 5.2 형변환 방법

형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주기만 하면 된다.

> (타입)피연산자
> 

기본형(primitive type)에서 boolean을 제외한 나머지 타입들을 서로 형변환이 가능하다

> 1 . boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2. 기본형과 참조형을 서로 형변환할 수 없다.
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로 형변환은 생략할 수 있다.
> 

# Chapter 03 | 연산자(operator)

## 1.1 연산자와 피연산자

연산자가 연산을 수행하려면 반드시 연산의 대상이 있어야하는데, 이것을 ‘피연산자(operand)’라고 한다.

> 연산자(operator) 연산을 수행하는 기호(+, -, *, / 등)
피연산자(operand) 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
> 

## 1.3 연산자의 종류

| 종류 | 연산자 | 설명 |
| --- | --- | --- |
| 산술 연산자 | +, -, *, /, %, <<, >> | 사칙연산(+,-,*,/)과 나머지 연산(%) |
| 비교 연산자 | >, <, ≥, ≤, ==, != | 크고 작음과 같고 다름을 비교 |
| 논리 연산자 | &&, ||, !, &, |, ^, ~ | ‘그리고(AND)’와 ‘또는(OR)’으로 조건을 연결 |
| 대입 연산자 | = | 우변의 값을 좌변에 저장 |
| 기타 | (type) ? : , instanceof | 형변환 연산자, 삼항 연산자, instanceof연산자 |

연산자는 위의 표에서 알 수 있는 것처럼, 크게 산술, 비교, 논리, 대입 4가지로 나눌 수 있다.

## 1.4 연산자의 우선순위와 결합규칙

> 1 . 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.
> 

## 1.5 산술 변환(usual arithmetic conversion)

> 산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
 - 두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치).
 - 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
> 

## 2.1 증감 연산자 ++ --

증감연산자는 피연산자에 저장된 값을 1증가 또는 감소시킨다. 증감연산자의 피연산자로 정수와 실수 모도 가능하지만, 상수의 값을 변경할 수 없으므로 가능하지 않다.

> 증가 연산자(++) 피연산자의 값을 1 증가시킨다.
감소 연산자(--) 피연산자의 값을 1 감소시킨다.
> 

일반적으로 단항 연산자는 피연산자의 왼쪽에 위치하지만, 증가 연산자 ’++’와 감소 연산자 ‘--’는 양쪽 모두 가능하다. 피연산자의 왼쪽에 위치하면 ‘전위형(prefix)’, 오른쪽에 위치하면 ‘후위형(postfix)’이라고 한다.

전위형과 후위형 모두 피연산자의 값을 1 증가 또는 감소시키지만, 증감연산자의 수식이나 메서드 호출에 포함된 경우 전위형일 때와 후위형일 떄의 결과가 다르다.

| 타입 | 설명 | 사용예 |
| --- | --- | --- |
| 전위형 | 값이 참조되기 전에 증가시킨다. | j = ++i; |
| 후위형 | 값이 참조된 후에 증가시킨다. | j = i++; |

## 3.1 사칙 연산자 +-*/

(간단한 내용은 생략)

3/2의 결과는 1.5또는 2가 아니라 1이다. 나눗셈의 결과는 반올림을 하는 것이 아니라 버린다는 점을 기억해야한다.

`(int)(pi * 1000 + 0.5) / 1000.0`

위의 예제는 소수점 넷째자리에서 반올림하는 방법을 보여준다. 이전 예제와 다른 점은 반올림을 위해 0.5를 더해 주는 것이다.

Math.round()를 사용하면 좀 더 간단히 반올림할 수 있다.

`Math.round(pi * 1000) / 1000.0`
